<!DOCTYPE html>
<html lang="en">

<head>
    <title>Trams in Zuid Holland</title>
    <meta property="og:description" content="Overzicht van tramlijnen in Zuid Holland" />
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css' />
    <link href='https://watergis.github.io/mapbox-gl-legend/mapbox-gl-legend.css' rel='stylesheet' />
    <script src='https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js'></script>
    <script src="https://watergis.github.io/mapbox-gl-legend/mapbox-gl-legend.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html,
        body,
        #map {
            height: 100%;
        }
    </style>
</head>

<body>
    <style>
        #file {
            position: absolute;
            top: 0;
            left: 0;
        }

        #legend {
            position: absolute;
            top: 0;
            right: 0;
            background-color: white;
            padding: 0.5em;
            border-radius: 0.5em;
            /* border-bottom-left-radius: 1em;
            border-bottom-right-radius: 1em; */
        }

        .maplibregl-popup {
            max-width: 400px;
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        }
    </style>
    <div id="map"></div>
    
    <!-- <input type="file" id="file" name="file" accept="application/geo+json,application/vnd.geo+json,.geojson" /> -->
    <div id="legend">Tramlijnen
        <div id="layers">
            <!-- <div><span style="width:0.1em;background-color: red;">&nbsp;&nbsp;&nbsp;</span> HTM</div> -->
        </div>
    </div>
    <script>
        (async () => {
            let positron_layers = await fetch('positron_layers.json')
                .then(function (response) {
                    return response.json();
                }).catch(function (err) {
                    console.log('error: ' + err);
                });
            
            const stylingMap = await fetch('stylingMap.json')
                .then(function (response) {
                    return response.json();
                }).catch(function (err) {
                    console.log('error: ' + err);
                });
            

        
        // const positron_stryle = await fetch('positron_style.json')
        //         .then(function (response) {
        //             return response.json();
        //         }).catch(function (err) {
        //             console.log('error: ' + err);
        //         });
        // console.log(positron_stryle)

        
        console.log(positron_layers)
        const map = new maplibregl.Map({
        container: 'map', // container id
    //     style: 'positron_style.json',
    //     antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
    // });
            
        style: {
            'version': 8,
            'sources': {
                'openmaptiles': {
                    'type': 'vector',
                    'tiles': [
                        // NOTE: Layers from Stadia Maps do not require an API key for localhost development or most production
                        // web deployments. See https://docs.stadiamaps.com/authentication/ for details.
                        'https://d1zqyi8v6vm8p9.cloudfront.net/planet/{z}/{x}/{y}.mvt'
                    ],
                    'maxzoom': 14
                },
                'raster-tiles': {
                    'type': 'raster',
                    'tiles': [
                        // NOTE: Layers from Stadia Maps do not require an API key for localhost development or most production
                        // web deployments. See https://docs.stadiamaps.com/authentication/ for details.
                        'http://a.tile.openstreetmap.org/{z}/{x}/{y}.png'
                    ],
                    'tileSize': 256,
                    'attribution':
                        'Map tiles by <a target="_blank" href="http://stamen.com">Stamen Design</a>; Hosting by <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a>. Data &copy; <a href="https://www.openstreetmap.org/about" target="_blank">OpenStreetMap</a> contributors'
                },



                // 'black-white-raster-tiles': {
                //     'type': 'raster',
                //     'tiles': [
                //         // NOTE: Layers from Stadia Maps do not require an API key for localhost development or most production
                //         // web deployments. See https://docs.stadiamaps.com/authentication/ for details.
                //         'http://www.toolserver.org/tiles/bw-mapnik/{z}/{x}/{y}.png'
                //     ],
                //     'tileSize': 256,
                //     'attribution':
                //     'Map tiles by <a target="_blank" href="http://stamen.com">Stamen Design</a>; Hosting by <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a>. Data &copy; <a href="https://www.openstreetmap.org/about" target="_blank">OpenStreetMap</a> contributors'
                // }
            },
            'layers': [
                // {
                //     'id': 'simple-tiles',
                //     'type': 'raster',
                //     'source': 'raster-tiles',
                //     'minzoom': 0,
                //     'maxzoom': 22,
                //     'background-color': '#CFB29C',
                //     'fill-opacity': 0.5,
                // },
                // {
                //     'id': 'black-white-tiles',
                //     'type': 'raster',
                //     'source': 'black-white-raster-tiles',
                //     'minzoom': 0,
                //     'maxzoom': 22
                // },
                // {
                //     'id': 'brown-background-color',
                //     'type': 'background',
                //     'paint': {
                //         'background-color': '#CFB29C',
                //         'background-opacity': 0.5
                //     }
                // }
                ...positron_layers,
                
                {
                    'id': 'vec-tiles',
                    'type': 'line',
                    'source': 'openmaptiles',
                    'source-layer': 'railway',
                    'minzoom': 0,
                    'maxzoom': 22
                },
                // {
                //     'id': 'simple-tiles-2',
                //     'type': 'line',
                //     'source': 'vector-tiles',
                //     'source-layer': 'landcover',
                //     'minzoom': 0,
                //     'maxzoom': 22
                // }
            ]
        },
        center: [4.284754, 52.111513],
            zoom: 8
    });

        // Create map
        // const map = new maplibregl.Map({
        //     container: 'map',
        //     style:
        //         'https://api.maptiler.com/maps/streets/style.json?key=zHbejlT5jba2uFpROztv',
        //     center: [4.284754, 52.111513],
        //     zoom: 8
        // });

        // Load data
        // On load map
        map.on('load', async () => {
            const tramData = await fetch('mygeodata_merged.geojson')
                .then(function (response) {
                    return response.json();
                }).catch(function (err) {
                    console.log('error: ' + err);
                });
                
            // console.log(tramData['features'].forEach(element => {
            //     console.log(element['properties']['color']);
            //     console.log(element['properties']['Operator']);
            // }));
            let legendMap = {}
            res = tramData['features'].map(element => {
                element['properties']['color'] = stylingMap['operators'][element['properties']['Operator']]
                legendMap[element['properties']['Operator']] = element['properties']['color']
                // return [element['properties']['Operator'], element['properties']['color']];
            });

            console.log(legendMap);

            document.getElementById('layers').innerHTML = Object.keys(legendMap).map(key => {
                return `<div><span style="width:0.1em;background-color: ${stylingMap['operators'][key]};">&nbsp;&nbsp;&nbsp;</span> ${key}</div>`
            }).join('')

            map.addSource('uploaded-source', {
                'type': 'geojson',
                'data': tramData
            });

            map.addLayer({
                'id': 'places',
                'type': 'line',
                'source': 'uploaded-source',
                'layout': {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                'paint': {
                    // 'line-color': '#888',
                    'line-color': ['get', 'color'],
                    'line-width': 8
                }
            });


            // Create popup handlers
            // Create a popup, but don't add it to the map yet.
            const popup = new maplibregl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('move', () => {
                const features = map.queryRenderedFeatures({ layers: ['places'] });

                // const displayFeatures = features.map((feat) => {
                //     const displayFeat = {};
                //     displayProperties.forEach((prop) => {
                //         displayFeat[prop] = feat[prop];
                //     });
                //     return displayFeat;
                // });

                console.log(features)


                let legendMap = {}
            res = features.map(element => {
                legendMap[element['properties']['Operator']] = element['properties']['color']
                // return [element['properties']['Operator'], element['properties']['color']];
            });

            console.log(legendMap);

            document.getElementById('layers').innerHTML = Object.keys(legendMap).map(key => {
                return `<div><span style="width:0.1em;background-color: ${stylingMap['operators'][key]};">&nbsp;&nbsp;&nbsp;</span> ${key}</div>`
            }).join('')
            });

            map.on('mouseenter', 'places', (e) => {
                // Change the cursor style as a UI indicator.
                map.getCanvas().style.cursor = 'pointer';

                // let coordinates = e.features[0].geometry.coordinates.slice();
                let coordinates = e.lngLat;
                const description = e.features[0].properties.description;
                const feature_name = e.features[0].properties.Name;
                const operator = e.features[0].properties.Operator;


                // Ensure that if the map is zoomed out such that multiple
                // copies of the feature are visible, the popup appears
                // over the copy being pointed to.
                console.log(e)
                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                // Populate the popup and set its coordinates
                // based on the feature found.
                // console.log(coordinates)
                if (coordinates[0] instanceof Array) {

                    coordinates = coordinates[0]
                    if (coordinates[0] instanceof Array) {

                        coordinates = coordinates[0]

                    }
                }

                
                // console.log(map.getSource('uploaded-source'))
                
                popup.setLngLat(coordinates).setHTML(`${operator} - ${feature_name}`).addTo(map);
            });

            map.on('mouseleave', 'places', () => {
                map.getCanvas().style.cursor = '';
                popup.remove();
            });
        });
    })();
    </script>
</body>

</html>